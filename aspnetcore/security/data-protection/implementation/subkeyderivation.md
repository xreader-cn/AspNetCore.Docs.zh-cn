---
title: ASP.NET Core 中的子项派生和已验证的加密
author: rick-anderson
description: 了解 ASP.NET Core 数据保护子项派生和经过身份验证的加密的实现细节。
ms.author: riande
ms.date: 10/14/2016
no-loc:
- ASP.NET Core Identity
- cookie
- Cookie
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: security/data-protection/implementation/subkeyderivation
ms.openlocfilehash: d8038142ccb2597eb1c98738307b8b9a842dae5a
ms.sourcegitcommit: 65add17f74a29a647d812b04517e46cbc78258f9
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/19/2020
ms.locfileid: "88630115"
---
# <a name="subkey-derivation-and-authenticated-encryption-in-aspnet-core"></a><span data-ttu-id="6e2bd-103">ASP.NET Core 中的子项派生和已验证的加密</span><span class="sxs-lookup"><span data-stu-id="6e2bd-103">Subkey derivation and authenticated encryption in ASP.NET Core</span></span>

<a name="data-protection-implementation-subkey-derivation"></a>

<span data-ttu-id="6e2bd-104">密钥环中的大多数密钥将包含某种形式的熵，并将具有说明 "CBC-模式加密 + HMAC 验证" 或 "GCM 加密 + 验证" 的算法信息。</span><span class="sxs-lookup"><span data-stu-id="6e2bd-104">Most keys in the key ring will contain some form of entropy and will have algorithmic information stating "CBC-mode encryption + HMAC validation" or "GCM encryption + validation".</span></span> <span data-ttu-id="6e2bd-105">在这些情况下，我们将嵌入的平均信息量称为此密钥的主密钥材料 (或千米) ，并执行密钥派生函数来派生用于实际加密操作的密钥。</span><span class="sxs-lookup"><span data-stu-id="6e2bd-105">In these cases, we refer to the embedded entropy as the master keying material (or KM) for this key, and we perform a key derivation function to derive the keys that will be used for the actual cryptographic operations.</span></span>

> [!NOTE]
> <span data-ttu-id="6e2bd-106">键是抽象的，自定义实现的行为可能不如下。</span><span class="sxs-lookup"><span data-stu-id="6e2bd-106">Keys are abstract, and a custom implementation might not behave as below.</span></span> <span data-ttu-id="6e2bd-107">如果密钥提供自己的实现 `IAuthenticatedEncryptor` 而不是使用我们的某个内置工厂，则本部分中所述的机制将不再适用。</span><span class="sxs-lookup"><span data-stu-id="6e2bd-107">If the key provides its own implementation of `IAuthenticatedEncryptor` rather than using one of our built-in factories, the mechanism described in this section no longer applies.</span></span>

<a name="data-protection-implementation-subkey-derivation-aad"></a>

## <a name="additional-authenticated-data-and-subkey-derivation"></a><span data-ttu-id="6e2bd-108">附加经过身份验证的数据和子项派生</span><span class="sxs-lookup"><span data-stu-id="6e2bd-108">Additional authenticated data and subkey derivation</span></span>

<span data-ttu-id="6e2bd-109">`IAuthenticatedEncryptor`接口用作所有经过身份验证的加密操作的核心接口。</span><span class="sxs-lookup"><span data-stu-id="6e2bd-109">The `IAuthenticatedEncryptor` interface serves as the core interface for all authenticated encryption operations.</span></span> <span data-ttu-id="6e2bd-110">其 `Encrypt` 方法使用两个缓冲区：纯文本和 additionalAuthenticatedData (AAD) 。</span><span class="sxs-lookup"><span data-stu-id="6e2bd-110">Its `Encrypt` method takes two buffers: plaintext and additionalAuthenticatedData (AAD).</span></span> <span data-ttu-id="6e2bd-111">纯文本内容在对的调用中保持不变 `IDataProtector.Protect` ，但 AAD 由系统生成并由三个部分组成：</span><span class="sxs-lookup"><span data-stu-id="6e2bd-111">The plaintext contents flow unchanged the call to `IDataProtector.Protect`, but the AAD is generated by the system and consists of three components:</span></span>

1. <span data-ttu-id="6e2bd-112">32位幻标头 09 F0 C9 F0，用于标识此版本的数据保护系统。</span><span class="sxs-lookup"><span data-stu-id="6e2bd-112">The 32-bit magic header 09 F0 C9 F0 that identifies this version of the data protection system.</span></span>

2. <span data-ttu-id="6e2bd-113">128位密钥 id。</span><span class="sxs-lookup"><span data-stu-id="6e2bd-113">The 128-bit key id.</span></span>

3. <span data-ttu-id="6e2bd-114">由创建了执行此操作的的、用于创建的可变长度字符串 `IDataProtector` 。</span><span class="sxs-lookup"><span data-stu-id="6e2bd-114">A variable-length string formed from the purpose chain that created the `IDataProtector` that's performing this operation.</span></span>

<span data-ttu-id="6e2bd-115">由于 AAD 对于所有三个组件的元组都是唯一的，因此我们可以使用它从公里派生新密钥，而不是在我们的所有加密操作中使用公里本身。</span><span class="sxs-lookup"><span data-stu-id="6e2bd-115">Because the AAD is unique for the tuple of all three components, we can use it to derive new keys from KM instead of using KM itself in all of our cryptographic operations.</span></span> <span data-ttu-id="6e2bd-116">对于每个调用 `IAuthenticatedEncryptor.Encrypt` ，将发生以下密钥派生过程：</span><span class="sxs-lookup"><span data-stu-id="6e2bd-116">For every call to `IAuthenticatedEncryptor.Encrypt`, the following key derivation process takes place:</span></span>

`( K_E, K_H ) = SP800_108_CTR_HMACSHA512(K_M, AAD, contextHeader || keyModifier)`

<span data-ttu-id="6e2bd-117">此处，我们将在计数器模式下调用 NIST SP800-108 KDF (参阅 [NIST SP800-108](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf)，5.1) ，其参数如下：</span><span class="sxs-lookup"><span data-stu-id="6e2bd-117">Here, we're calling the NIST SP800-108 KDF in Counter Mode (see [NIST SP800-108](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), Sec. 5.1) with the following parameters:</span></span>

* <span data-ttu-id="6e2bd-118">密钥派生密钥 (KDK) = `K_M`</span><span class="sxs-lookup"><span data-stu-id="6e2bd-118">Key derivation key (KDK) = `K_M`</span></span>

* <span data-ttu-id="6e2bd-119">PRF = HMACSHA512</span><span class="sxs-lookup"><span data-stu-id="6e2bd-119">PRF = HMACSHA512</span></span>

* <span data-ttu-id="6e2bd-120">标签 = additionalAuthenticatedData</span><span class="sxs-lookup"><span data-stu-id="6e2bd-120">label = additionalAuthenticatedData</span></span>

* <span data-ttu-id="6e2bd-121">context = contextHeader | |keyModifier</span><span class="sxs-lookup"><span data-stu-id="6e2bd-121">context = contextHeader || keyModifier</span></span>

<span data-ttu-id="6e2bd-122">上下文标头的长度可变，主要用作我们要派生和的算法的指纹 `K_E` `K_H` 。</span><span class="sxs-lookup"><span data-stu-id="6e2bd-122">The context header is of variable length and essentially serves as a thumbprint of the algorithms for which we're deriving `K_E` and `K_H`.</span></span> <span data-ttu-id="6e2bd-123">密钥修饰符是为每次调用随机生成的128位字符串， `Encrypt` 可确保 KE 和 KH 对于此特定身份验证加密操作是唯一的，即使 KDF 的所有其他输入都是常量，也是如此。</span><span class="sxs-lookup"><span data-stu-id="6e2bd-123">The key modifier is a 128-bit string randomly generated for each call to `Encrypt` and serves to ensure with overwhelming probability that KE and KH are unique for this specific authentication encryption operation, even if all other input to the KDF is constant.</span></span>

<span data-ttu-id="6e2bd-124">对于 CBC 模式加密 + HMAC 验证操作， `| K_E |` 是对称块加密密钥的长度， `| K_H |` 是 HMAC 例程的摘要大小。</span><span class="sxs-lookup"><span data-stu-id="6e2bd-124">For CBC-mode encryption + HMAC validation operations, `| K_E |` is the length of the symmetric block cipher key, and `| K_H |` is the digest size of the HMAC routine.</span></span> <span data-ttu-id="6e2bd-125">对于 GCM 加密 + 验证操作，为 `| K_H | = 0` 。</span><span class="sxs-lookup"><span data-stu-id="6e2bd-125">For GCM encryption + validation operations, `| K_H | = 0`.</span></span>

## <a name="cbc-mode-encryption--hmac-validation"></a><span data-ttu-id="6e2bd-126">CBC 模式加密 + HMAC 验证</span><span class="sxs-lookup"><span data-stu-id="6e2bd-126">CBC-mode encryption + HMAC validation</span></span>

<span data-ttu-id="6e2bd-127">`K_E`通过上述机制生成一次后，我们将生成一个随机初始化向量，并运行对称块加密算法以加密纯文本。</span><span class="sxs-lookup"><span data-stu-id="6e2bd-127">Once `K_E` is generated via the above mechanism, we generate a random initialization vector and run the symmetric block cipher algorithm to encipher the plaintext.</span></span> <span data-ttu-id="6e2bd-128">然后，初始化向量和密码文本通过用密钥初始化的 HMAC 例程运行， `K_H` 以生成 MAC。</span><span class="sxs-lookup"><span data-stu-id="6e2bd-128">The initialization vector and ciphertext are then run through the HMAC routine initialized with the key `K_H` to produce the MAC.</span></span> <span data-ttu-id="6e2bd-129">下面以图形方式表示此过程和返回值。</span><span class="sxs-lookup"><span data-stu-id="6e2bd-129">This process and the return value is represented graphically below.</span></span>

![CBC 模式进程和返回](subkeyderivation/_static/cbcprocess.png)

`output:= keyModifier || iv || E_cbc (K_E,iv,data) || HMAC(K_H, iv || E_cbc (K_E,iv,data))`

> [!NOTE]
> <span data-ttu-id="6e2bd-131">在 `IDataProtector.Protect` 将 [幻标题和密钥 id](xref:security/data-protection/implementation/authenticated-encryption-details) 返回到调用方之前，实现会将其追加到输出之前。</span><span class="sxs-lookup"><span data-stu-id="6e2bd-131">The `IDataProtector.Protect` implementation will [prepend the magic header and key id](xref:security/data-protection/implementation/authenticated-encryption-details) to output before returning it to the caller.</span></span> <span data-ttu-id="6e2bd-132">由于幻标头和密钥 id 是 [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad)的一部分，并且由于密钥修饰符作为输入送回 KDF，这意味着最终返回的有效负载的每个字节都由 MAC 进行身份验证。</span><span class="sxs-lookup"><span data-stu-id="6e2bd-132">Because the magic header and key id are implicitly part of [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), and because the key modifier is fed as input to the KDF, this means that every single byte of the final returned payload is authenticated by the MAC.</span></span>

## <a name="galoiscounter-mode-encryption--validation"></a><span data-ttu-id="6e2bd-133">Galois/Counter 模式加密 + 验证</span><span class="sxs-lookup"><span data-stu-id="6e2bd-133">Galois/Counter Mode encryption + validation</span></span>

<span data-ttu-id="6e2bd-134">`K_E`通过上述机制生成一次后，我们将生成一个随机的96位 nonce，并运行对称块加密算法以加密纯文本并生成128位身份验证标记。</span><span class="sxs-lookup"><span data-stu-id="6e2bd-134">Once `K_E` is generated via the above mechanism, we generate a random 96-bit nonce and run the symmetric block cipher algorithm to encipher the plaintext and produce the 128-bit authentication tag.</span></span>

![GCM 模式进程和返回](subkeyderivation/_static/galoisprocess.png)

`output := keyModifier || nonce || E_gcm (K_E,nonce,data) || authTag`

> [!NOTE]
> <span data-ttu-id="6e2bd-136">尽管 GCM 本身支持 AAD 的概念，但我们仍只向原始 KDF 提供 AAD，选择将空字符串传递给 GCM 以用于其 AAD 参数。</span><span class="sxs-lookup"><span data-stu-id="6e2bd-136">Even though GCM natively supports the concept of AAD, we're still feeding AAD only to the original KDF, opting to pass an empty string into GCM for its AAD parameter.</span></span> <span data-ttu-id="6e2bd-137">这样做的原因是两折。</span><span class="sxs-lookup"><span data-stu-id="6e2bd-137">The reason for this is two-fold.</span></span> <span data-ttu-id="6e2bd-138">首先， [为了支持灵活性](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) ，我们永远不希望将其 `K_M` 作为加密密钥直接使用。</span><span class="sxs-lookup"><span data-stu-id="6e2bd-138">First, [to support agility](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) we never want to use `K_M` directly as the encryption key.</span></span> <span data-ttu-id="6e2bd-139">此外，GCM 对其输入施加非常严格的唯一性要求。</span><span class="sxs-lookup"><span data-stu-id="6e2bd-139">Additionally, GCM imposes very strict uniqueness requirements on its inputs.</span></span> <span data-ttu-id="6e2bd-140">对于两个或多个具有相同 (键的不同输入数据集，GCM) 对的概率不能超过 2 ^ 32。</span><span class="sxs-lookup"><span data-stu-id="6e2bd-140">The probability that the GCM encryption routine is ever invoked on two or more distinct sets of input data with the same (key, nonce) pair must not exceed 2^32.</span></span> <span data-ttu-id="6e2bd-141">如果修复此问题，我们在 `K_E` 运行落入的 2 ^-32 限制之前，不能执行 2 ^ 32 个以上的加密操作。</span><span class="sxs-lookup"><span data-stu-id="6e2bd-141">If we fix `K_E` we cannot perform more than 2^32 encryption operations before we run afoul of the 2^-32 limit.</span></span> <span data-ttu-id="6e2bd-142">这似乎是一种非常大的操作，但高流量 web 服务器可以在一天内只经过4000000000请求，在这些密钥的正常生存期内。</span><span class="sxs-lookup"><span data-stu-id="6e2bd-142">This might seem like a very large number of operations, but a high-traffic web server can go through 4 billion requests in mere days, well within the normal lifetime for these keys.</span></span> <span data-ttu-id="6e2bd-143">为了保持符合 2 ^-32 概率限制，我们继续使用128位的密钥修饰符和96位 nonce，这会大大扩展任何给定的可用操作计数 `K_M` 。</span><span class="sxs-lookup"><span data-stu-id="6e2bd-143">To stay compliant of the 2^-32 probability limit, we continue to use a 128-bit key modifier and 96-bit nonce, which radically extends the usable operation count for any given `K_M`.</span></span> <span data-ttu-id="6e2bd-144">为简单起见，我们在 CBC 和 GCM 操作之间共享 KDF 代码路径，由于 AAD 已在 KDF 中考虑，因此无需将其转发到 GCM 例程。</span><span class="sxs-lookup"><span data-stu-id="6e2bd-144">For simplicity of design we share the KDF code path between CBC and GCM operations, and since AAD is already considered in the KDF there's no need to forward it to the GCM routine.</span></span>
